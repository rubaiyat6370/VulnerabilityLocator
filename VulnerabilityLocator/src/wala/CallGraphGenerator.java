package wala;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.ibm.wala.analysis.arraybounds.ArrayBoundsGraphBuilder;
import com.ibm.wala.cast.ir.ssa.AstIRFactory;
import com.ibm.wala.cast.js.callgraph.fieldbased.flowgraph.FlowGraph;
import com.ibm.wala.cast.js.callgraph.fieldbased.flowgraph.FlowGraphBuilder.FlowGraphSSAVisitor;
import com.ibm.wala.cast.js.ipa.callgraph.JSCallGraphUtil;
import com.ibm.wala.cast.js.test.JSCallGraphBuilderUtil;
import com.ibm.wala.cast.js.translator.CAstRhinoTranslatorFactory;
import com.ibm.wala.cast.types.AstMethodReference;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.AnalysisCache;

import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.impl.Everywhere;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.IRFactory;
import com.ibm.wala.ssa.SSACFG;
import com.ibm.wala.ssa.SSAGetCaughtExceptionInstruction;
import com.ibm.wala.ssa.SSAIndirectionData;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAOptions;
import com.ibm.wala.ssa.SSAPhiInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.ssa.SSACFG.BasicBlock;
import com.ibm.wala.ssa.SSACFG.ExceptionHandlerBasicBlock;
import com.ibm.wala.types.TypeName;

import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.collections.HashMapFactory;

import com.ibm.wala.util.strings.StringStuff;

/**
 *
 * Date 04/10/2017 11:15:54 PM Author Rubaiyat Jahan Mumu
 * 
 **/

public class CallGraphGenerator {

	private IMethod method;
	private SSAOptions options;
	private SSACFG cfg;
	private SSAInstruction[] instructions;
	private SymbolTable symbolTable;
	private Collection<? extends SSAIndirectionData.Name> names = null;

	List<List<String>> graph = new ArrayList<List<String>>();
	List<String> node = new ArrayList<>();

	List<List<String>> vgraph = new ArrayList<List<String>>();
	List<String> vnode = new ArrayList<>();
	List<String> vulRelation = new ArrayList<>();

	private AnalysisCache ac = null;

	private int createCallList(String a) {
		String[] name = a.split("/");
		node.add(name[2]);
		vnode.add(name[2]);
		return name.length;
	}

	private String checkFuncCall(String line) {
		String[] words = line.split(":|\\@| ");
		List<String> arrayToList = Arrays.asList(words);
		int pos = arrayToList.indexOf("lexical");
		if (pos != -1) {
			String func = arrayToList.get(pos + 1);
			Pattern pattern = Pattern.compile("(?i)((.*?)((en)|(de))((code)|(cipher)|(crypt))(.*?))", Pattern.CASE_INSENSITIVE);
			Matcher matcher = pattern.matcher(func);
			
			if(matcher.find()) 
				vulRelation.add(func);
			return func;
		}

		else
			return null;

	}

	private String getInstructions(String line) {
		if (line != null) {
			if (line.contains("binaryop")) {
				return "BINARY-OP";
			}
			if (line.contains("new")) {
				return "NEW";
			}
			if (line.contains("putfield")) {
				return "PUTFIELD";
			}
			
			if (line.contains("conditional branch")) {
				return "CONDITIONAL";
			}
			if (line.contains("return")) {
				return "RETURN";
			}

			if (line.contains("global:global")) {
				return "GLOBAL";
			}
			if(line.contains("phi")) {
				return "PHI";
			}
			
			if (line.contains("charAt") || line.contains("charCodeAt")|| line.contains("concat") ||
					line.contains("endsWith") || line.contains("fromCharCode") || line.contains("includes") ||
					line.contains("indexOf") || line.contains("lastIndexOf") || line.contains("localeCompare") ||
					line.contains("match") || line.contains("repeat") || line.contains("replace") || 
					line.contains("search") || line.contains("slice") || line.contains("split") || 
					line.contains("startsWith") || line.contains("substr") || line.contains("substring") ||
					line.contains("toLocaleLowerCase") || line.contains("toLocaleUpperCase") || 
					line.contains("toLowerCase") || line.contains("toUpperCase") || line.contains("toString") || 
					line.contains("trim") || line.contains("valueOf")) {
				return "STRING-OP";
			}
		}
		return null;
	}

	public void printIR(IR ir) {

		String a = method.toString();
		int pos_window_main = a.indexOf("__WINDOW_MAIN__");
		int last = a.indexOf(">");
		int pos_make_node = a.indexOf("make_node");

		// remove unnecessary nodes
		if (pos_window_main == -1 || pos_make_node != -1 || pos_window_main + 15 == last)
			return;
		System.out.println("\n\n" + a + " ");

		if (createCallList(a) > 3)
			return;
		List<String> l = new ArrayList<String>();
		List<String> ver = new ArrayList<String>();

		if (node.size() > 0) {
			l.add("callee of " + node.get(node.size() - 1));
			ver.add("Instructions of " + vnode.get(vnode.size() - 1));
		}
		// StringBuffer result = new StringBuffer(method.toString());
		// print cfg of a node
		System.out.println("CFG:\n");
		// System.out.println(cfg.toString());

		// print instructions of a block
		// System.out.println("Instructions:\n");
		for (int i = 0; i < cfg.getMaxNumber(); i++) {
			BasicBlock bb = cfg.getBasicBlock(i);
			int start = bb.getFirstInstructionIndex();
			int end = bb.getLastInstructionIndex();
			// result.append("BB").append(bb.getNumber());
			System.out.print("BB" + bb.getNumber() + "\n");
			System.out.println("Phi instructions: \n");
			for (Iterator it = bb.iteratePhis(); it.hasNext();) {
				SSAPhiInstruction phi = (SSAPhiInstruction) it.next();
				if (phi != null) {
					// result.append(" " + phi.toString(symbolTable)).append("\n");
					System.out.println(" " + phi.toString(symbolTable) + ("\n"));
					ver.add("PHI");
					
				}
			}

			if (bb instanceof ExceptionHandlerBasicBlock) {
				ExceptionHandlerBasicBlock ebb = (ExceptionHandlerBasicBlock) bb;
				SSAGetCaughtExceptionInstruction s = ebb.getCatchInstruction();
				if (s != null) {
					// result.append(" " + s.toString(symbolTable)).append("\n");
				} else {
					// result.append(" " + " No catch instruction. Unreachable?\n");
				}
			}
			System.out.println("Normal Instructions: \n");
			for (int j = start; j <= end; j++) {
				if (instructions[j] != null) {
					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getUse(j, n) != -1) {

								int s = ir.getIndirectionData().getUse(j, n);
								// result.append(" " + n + " -> " + ir.getIndirectionData().getUse(j, n));
								System.out.print(" " + n + " -> " + ir.getIndirectionData().getUse(j, n));
								any = true;
							}
						}
						if (any) {
							// result.append("\n");
							System.out.println();
						}
					}
					StringBuffer x = new StringBuffer(j + "   " + instructions[j].toString(symbolTable) + "");
					String func = checkFuncCall(instructions[j].toString(symbolTable));
					String inst = getInstructions(instructions[j].toString(symbolTable));
					if (func != null) {
						l.add(func);
						ver.add("CALL " + func);
					}
					else if(inst!=null) {
						ver.add(inst);
					}
					StringStuff.padWithSpaces(x, 45);
					System.out.print(x + "**" + ir.instructionPosition(j));
					// result.append(x);
					// result.append(ir.instructionPosition(j));

					Map<Integer, Set<String>> valNames = HashMapFactory.make();
					for (int v = 0; v < instructions[j].getNumberOfDefs(); v++) {
						int valNum = instructions[j].getDef(v);
						ir.addNames(j, valNames, valNum);
					}
					for (int v = 0; v < instructions[j].getNumberOfUses(); v++) {
						int valNum = instructions[j].getUse(v);
						ir.addNames(j, valNames, valNum);
					}
					if (!valNames.isEmpty()) {
						// result.append(" [");
						System.out.print(" [");
						for (Map.Entry<Integer, Set<String>> e : valNames.entrySet()) {
							int key = e.getKey();
							Set<String> s = e.getValue();
							System.out.print(key + "=" + s.toString());
							// result.append(key + "=" + s.toString());
						}
						// result.append("]");
						System.out.print("]");
					}
					System.out.println();
					// result.append("\n");

					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getDef(j, n) != -1) {
								// result.append(" " + n + " <- " + ir.getIndirectionData().getDef(j, n));
								System.out.print(" " + n + " <- " + ir.getIndirectionData().getDef(j, n));
								any = true;
							}
						}
						if (any) {
							// result.append("\n");
							System.out.println("\n");
						}
					}
				}
			}

		}

		graph.add(l);
		vgraph.add(ver);
		// System.out.println(result);

	}

	public void initIR(IMethod method, SSAInstruction[] instructions, SymbolTable symbolTable, SSACFG cfg,
			SSAOptions options) {
		if (method == null) {
			throw new IllegalArgumentException("method is null");
		}
		this.method = method;
		this.instructions = instructions;
		this.symbolTable = symbolTable;
		this.cfg = cfg;
		this.options = options;

	}

	private void sendDataToinitIR(IR ir) {
		IMethod method = ir.getMethod();
		SSAInstruction[] instructions = ir.getInstructions();
		SymbolTable symbolTable = ir.getSymbolTable();
		SSACFG cfg = ir.getControlFlowGraph();
		this.names = ir.getNames();
		initIR(method, instructions, symbolTable, cfg, options);

		printIR(ir);
	}

	public static void main(String args[])
			throws IllegalArgumentException, IOException, CancelException, WalaException {

		String dir = "D:\\SPL3\\VulnerabilityLocator\\VulnerabilityLocator";
		String file = "htmlPage.html"; // bundle-bg.js //htmlPage.html
		File f = new File(dir + "\\" + file);
		JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());

		// URL u = new URL(f.getAbsolutePath());
		// CallGraph cg = JSCallGraphBuilderUtil.makeScriptCG(dir, file);
		CallGraph cg = JSCallGraphBuilderUtil.makeHTMLCG(f.toURI().toURL());
		CallGraphGenerator cgg = new CallGraphGenerator();

		cgg.getFunctionNode(cg, dir, file);
		// printIRs("bundle-bg.js");
	}

	private void getFunctionNode(CallGraph CG, String dir, String file) {
		TypeName type = TypeName.findOrCreate("L" + file); // + dir + "/"
		// System.out.println("Type name of file: " + type);
		if (CG != null) {
			// System.out.println("Call graph is not null:" + CG);
			Iterator<CGNode> iter = CG.iterator();
			IClassHierarchy che = CG.getClassHierarchy();

			CGNode node;
			while (iter.hasNext()) {
				node = iter.next();

				TypeName tempType = node.getMethod().getDeclaringClass().getName();

				// String src = node.getMethod().getDeclaringClass().getSourceFileName();
				/*
				 * IR ir = node.getIR(); System.out.println(ir.getControlFlowGraph());
				 */
				if (tempType.toString().startsWith("L" + file)) {
					// System.out.println("Class Heirarchy :" +ich.getScope());
					IR ir = node.getIR();
					sendDataToinitIR(ir);
					IMethod method = ir.getMethod();
					// System.out.println("Type name of node : " + method.getReference());
					// System.out.println("Method initializer:" + method.getLineNumber(0));
					SSAInstruction[] instructions = ir.getInstructions();
					Iterator<SSAInstruction> iterator = (Iterator<SSAInstruction>) ir.iteratePhis();
					SSAInstruction ins;

					String string = ir.toString();
					WriteFileExample.writeFile(string);

					// System.out.println(string);
					for (int instructionIndex = 0; instructionIndex < instructions.length; instructionIndex++) {
						SSAInstruction instruction = instructions[instructionIndex];
						String[] local = ir.getLocalNames(instructionIndex, 5);
						// System.out.println("Local length :" + local.length);

						// System.out.println("Local names for instruction" +
						// ir.getLocalNames(instructionIndex, 0));;
						// System.out.println(ir.getBasicBlockForInstruction(instruction));
						// System.out.println(instruction);
					}

					// System.out.println();

				}
			}
			System.out.println(graph);
			System.out.println(vgraph);
			System.out.println(vulRelation);
		}
	}

	public static void printIRs(String filename) throws ClassHierarchyException {
		// use Rhino to parse JavaScript
		JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
		// build a class hierarchy, for access to code info
		IClassHierarchy cha = JSCallGraphUtil.makeHierarchyForScripts(filename);
		// for constructing IRs
		IRFactory<IMethod> factory = AstIRFactory.makeDefaultFactory();
		for (IClass klass : cha) {
			// ignore models of built-in JavaScript methods
			if (!klass.getName().toString().startsWith("Lprologue.js")) {
				// get the IMethod representing the code (the ‘do’ method)
				IMethod m = klass.getMethod(AstMethodReference.fnSelector);
				if (m != null) {
					IR ir = factory.makeIR(m, Everywhere.EVERYWHERE, new SSAOptions());
					System.out.println(ir);
				}
			}
		}
	}

	/*
	 * public void visitFunction(FlowGraph flowgraph, IMethod method) { { if
	 * (method.toString().contains("ctor") &&
	 * method.toString().contains("dollar_init")) { System.err.println("found it");
	 * } AnalysisCache cache = null; IR ir = cache.getIR(method);
	 * FlowGraphSSAVisitor visitor = new FlowGraphSSAVisitor(ir, flowgraph);
	 * 
	 * // first visit normal instructions SSAInstruction[] normalInstructions =
	 * ir.getInstructions(); for(int i=0;i<normalInstructions.length;++i)
	 * if(normalInstructions[i] != null) { visitor.instructionIndex = i;
	 * normalInstructions[i].visit(visitor); }
	 * 
	 * // now visit phis and catches visitor.instructionIndex = -1; for(Iterator<?
	 * extends SSAInstruction> iter=ir.iteratePhis();iter.hasNext();)
	 * iter.next().visit(visitor);
	 * 
	 * for(Iterator<SSAInstruction>
	 * iter=ir.iterateCatchInstructions();iter.hasNext();)
	 * iter.next().visit(visitor); } }
	 */

}

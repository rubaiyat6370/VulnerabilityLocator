package wala;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.ibm.wala.analysis.arraybounds.ArrayBoundsGraphBuilder;
import com.ibm.wala.cast.ir.ssa.AstIRFactory;
import com.ibm.wala.cast.js.callgraph.fieldbased.flowgraph.FlowGraph;
import com.ibm.wala.cast.js.callgraph.fieldbased.flowgraph.FlowGraphBuilder.FlowGraphSSAVisitor;
import com.ibm.wala.cast.js.ipa.callgraph.JSCallGraphUtil;
import com.ibm.wala.cast.js.test.JSCallGraphBuilderUtil;
import com.ibm.wala.cast.js.translator.CAstRhinoTranslatorFactory;
import com.ibm.wala.cast.types.AstMethodReference;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.AnalysisCache;

import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.impl.Everywhere;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.shrikeBT.info.ThisAssignmentChecker;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.IRFactory;
import com.ibm.wala.ssa.SSACFG;
import com.ibm.wala.ssa.SSAGetCaughtExceptionInstruction;
import com.ibm.wala.ssa.SSAIndirectionData;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAOptions;
import com.ibm.wala.ssa.SSAPhiInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.ssa.SSACFG.BasicBlock;
import com.ibm.wala.ssa.SSACFG.ExceptionHandlerBasicBlock;
import com.ibm.wala.types.TypeName;

import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.collections.HashMapFactory;

import com.ibm.wala.util.strings.StringStuff;

import ruleFile.SourceSink;
import ruleFile.SourceSinkTrack;

import java.util.Map;

/**
 *
 * Date 04/10/2017 11:15:54 PM Author Rubaiyat Jahan Mumu
 * 
 **/

public class CallGraphGenerator {

	private IMethod method;
	private SSAOptions options;
	private SSACFG cfg;
	private SSAInstruction[] instructions;
	private SymbolTable symbolTable;
	private Collection<? extends SSAIndirectionData.Name> names = null;

	List<List<String>> graph = new ArrayList<List<String>>();
	List<String> node = new ArrayList<>();

	static List<SourceSinkTrack> srcSnk;

	List<List<String>> vgraph = new ArrayList<List<String>>();
	List<String> vnode = new ArrayList<>();
	List<String> vulRelation = new ArrayList<>();
	List<String> sensitiveSrc = new ArrayList<>();
	List<String> sensitiveSnk = new ArrayList<>();
	List<List<String>> variableGraph = new ArrayList<>();
	Map<String, List<String>> map = new HashMap<String, List<String>>();
	List<String> encryptedVariable = new ArrayList<>();
	List<String> decryptedVariable = new ArrayList<>();

	private int createCallList(String a) {
		String[] name = a.split("/");
		node.add(name[2]);
		vnode.add(name[2]);
		return name.length;
	}
	
	private void getEncryptedAndDecryptedVar(String line) {
		String[] words = line.split(":|\\@| ");
		List<String> arrayToList = Arrays.asList(words);
		int pos = arrayToList.indexOf("lexical");
		if (pos != -1) {
			String func = arrayToList.get(pos + 1);
			Pattern encrypt = Pattern.compile("(?i)((.*?)((en))((code)|(cipher)|(crypt))(.*?))",
					Pattern.CASE_INSENSITIVE);
			Matcher encryptMatcher = encrypt.matcher(func);
			
			Pattern dncrypt = Pattern.compile("(?i)((.*?)((de))((code)|(cipher)|(crypt))(.*?))",
					Pattern.CASE_INSENSITIVE);
			Matcher decryptMatcher = dncrypt.matcher(func);
			
			Pattern pattern = Pattern.compile("(v[0-9]*\\s\\=)");
			Matcher matcher = pattern.matcher(line);
			String[] str = line.split(" |=");
			if (decryptMatcher.find())
			{
				
				if (matcher.find()) {
					
					decryptedVariable.add(str[0]);
					
				}
			}
			
			if (encryptMatcher.find())
			{
				if (matcher.find()) {
					
					encryptedVariable.add(str[0]);

				}
				
			}
		
		}
	}

	private String checkFuncCall(String line) {
		String[] words = line.split(":|\\@| ");
		List<String> arrayToList = Arrays.asList(words);
		int pos = arrayToList.indexOf("lexical");
		if (pos != -1) {
			String func = arrayToList.get(pos + 1);
			Pattern pattern = Pattern.compile("(?i)((.*?)((en)|(de))((code)|(cipher)|(crypt))(.*?))",
					Pattern.CASE_INSENSITIVE);
			Matcher matcher = pattern.matcher(func);

			if (matcher.find())
			{
				vulRelation.add(func);
			}
			return func;
		}

		else
			return null;

	}

	private void getVariableUseGraph(String line1, String instType) {
		Pattern pattern = Pattern.compile("(v[0-9]*\\s\\=)");
		Matcher matcher = pattern.matcher(line1);
		String[] str = line1.split(" |=");
		if (instType == "src") {
			

			if (matcher.find()) {
				
				sensitiveSrc.add(str[0]);
				map.put(str[0], new ArrayList<String>());

			}
		}
		
		if(instType == "snk") {
			sensitiveSnk.add(str[0]);
		}
	}

	private void searchMatchingVar(String line) {

		String[] tokens = line.split("=");
		Pattern pattern = Pattern.compile("(v[0-9]+\\s\\=)");
		Matcher matcher = pattern.matcher(line);

		List<String> newKeys = new ArrayList<String>();

		if (tokens.length == 2) {
			if (matcher.find()) {

				for (String key : map.keySet()) {

					tokens[1] += " ";// for matching in the regex
					Pattern p = Pattern.compile(key + "[^(0-9)]");
					Matcher m = p.matcher(tokens[1]);

					if (m.find()) {
						String newKey = tokens[0].trim();
						List<String> values = map.get(key);
						if (!values.contains(newKey)) {
							values.add(newKey);
						}
						if (!map.containsKey(newKey)) {
							newKeys.add(newKey);
						}

					}
				}

				for (String key : newKeys) {
					map.put(key, new ArrayList<>());
				}

			}
		}
	}

	private String getInstructions(String line) {
		if (line != null) {
			if (line.contains("binaryop")) {
				return "BINARY-OP";
			}
			if (line.contains("new")) {
				return "NEW";
			}
			if (line.contains("putfield")) {
				return "PUTFIELD";
			}

			if (line.contains("conditional branch")) {
				return "CONDITIONAL";
			}
			if (line.contains("return")) {
				return "RETURN";
			}

			if (line.contains("global:global")) {
				return "GLOBAL";
			}
			if (line.contains("phi")) {
				return "PHI";
			}

			if (line.contains("charAt") || line.contains("charCodeAt") || line.contains("concat")
					|| line.contains("endsWith") || line.contains("fromCharCode") || line.contains("includes")
					|| line.contains("indexOf") || line.contains("lastIndexOf") || line.contains("localeCompare")
					|| line.contains("match") || line.contains("repeat") || line.contains("replace")
					|| line.contains("search") || line.contains("slice") || line.contains("split")
					|| line.contains("startsWith") || line.contains("substr") || line.contains("substring")
					|| line.contains("toLocaleLowerCase") || line.contains("toLocaleUpperCase")
					|| line.contains("toLowerCase") || line.contains("toUpperCase") || line.contains("toString")
					|| line.contains("trim") || line.contains("valueOf")) {
				return "STRING-OP";
			}
		}
		return null;
	}

	public String getSrcSnkLineNumber(String instPosLine) {
		String[] str = instPosLine.split("\\[|\\]|\\(|\\)|:");

		List<String> list = Arrays.asList(str);

		if (list.size() == 11) {
			list.set(7, list.get(7).trim());

			String[] no = list.get(10).split(" ");
			no[1] = no[1].trim();

			for (int j = 0; j < srcSnk.size(); j++) {

				if (srcSnk.get(j).filename.equals(list.get(7)) && srcSnk.get(j).lineNumber.equals(no[1])) {
					return srcSnk.get(j).type;
				}
			}

		}

		return null;
	}

	public static void printList(List<String> list, List<String> line) {
		for (int i = 0; i < list.size(); i++)
			System.out.println(line.get(i) + " " + list.get(i));
	}

	private List<List<String>> GetAllPaths(Map<String, List<String>> variableUseMap) {

		List<List<String>> paths = new ArrayList<List<String>>();
		

		Stack<SubTree> stack = new Stack<SubTree>();
		for (String variable : variableUseMap.keySet()) {
			stack.push(new SubTree(variable, Arrays.asList(variable)));
			List<String> visited = new ArrayList<String>();
			do {
				SubTree item = stack.pop();
				visited.add(item.Node);
				boolean isChildFound = false;
				for (String key : variableUseMap.keySet()) {

					if (variableUseMap.get(key).contains(item.Node)) {
						List<String> newPath = new ArrayList<String>(item.Path);
						 newPath.add(key);
						if(!visited.contains(key)) {
							stack.push(new SubTree(key, newPath));
							isChildFound = true;
						}
						
					}
				}
				if (!isChildFound) {
					paths.add(item.Path);
				}
			} while (!stack.isEmpty());
		}

		return paths;
	}

	public void printIR(IR ir) {

		String a = method.toString();
		int pos_window_main = a.indexOf("__WINDOW_MAIN__");
		int last = a.indexOf(">");
		int pos_make_node = a.indexOf("make_node");

		// remove unnecessary nodes
		if (pos_window_main == -1 || pos_make_node != -1 || pos_window_main + 15 == last)
			return;
		System.out.println("\n\n" + a + " ");

		if (createCallList(a) > 3)
			return;
		List<String> l = new ArrayList<String>();
		List<String> ver = new ArrayList<String>();

		if (node.size() > 0) {
			l.add("callee of " + node.get(node.size() - 1));
			ver.add("Instructions of " + vnode.get(vnode.size() - 1));
		}

		System.out.println("CFG:\n");

		for (int i = 0; i < cfg.getMaxNumber(); i++) {
			BasicBlock bb = cfg.getBasicBlock(i);
			int start = bb.getFirstInstructionIndex();
			int end = bb.getLastInstructionIndex();

			System.out.print("BB" + bb.getNumber() + "\n");
			System.out.println("Phi instructions: \n");
			for (Iterator it = bb.iteratePhis(); it.hasNext();) {
				SSAPhiInstruction phi = (SSAPhiInstruction) it.next();
				if (phi != null) {

					System.out.println(" " + phi.toString(symbolTable) + ("\n"));
					ver.add("PHI");

				}
			}

			System.out.println("Normal Instructions: \n");
			for (int j = start; j <= end; j++) {
				if (instructions[j] != null) {
					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getUse(j, n) != -1) {

								int s = ir.getIndirectionData().getUse(j, n);

								System.out.print(" " + n + " -> " + s);
								any = true;
							}
						}
						if (any) {

							System.out.println();
						}
					}
					StringBuffer x = new StringBuffer(j + "   " + instructions[j].toString(symbolTable) + "");

					String line = instructions[j].toString(symbolTable);
					String func = checkFuncCall(line);
					String inst = getInstructions(line);
					getEncryptedAndDecryptedVar(line);
					String instType = getSrcSnkLineNumber(ir.instructionPosition(j));
					getVariableUseGraph(line, instType);
					searchMatchingVar(line);
					if (instType != null)
						ver.add("Type: " + instType); // src or sink

					if (func != null) {
						l.add(func);
						ver.add("CALL " + func);
					} else if (inst != null) {
						ver.add(inst);
					}
					StringStuff.padWithSpaces(x, 45);
					System.out.print(x + "\n" + ir.instructionPosition(j));

					Map<Integer, Set<String>> valNames = HashMapFactory.make();
					for (int v = 0; v < instructions[j].getNumberOfDefs(); v++) {
						int valNum = instructions[j].getDef(v);
						ir.addNames(j, valNames, valNum);
					}
					for (int v = 0; v < instructions[j].getNumberOfUses(); v++) {
						int valNum = instructions[j].getUse(v);
						ir.addNames(j, valNames, valNum);
					}
					if (!valNames.isEmpty()) {

						System.out.print(" [");
						for (Map.Entry<Integer, Set<String>> e : valNames.entrySet()) {
							int key = e.getKey();
							Set<String> s = e.getValue();
							System.out.print(key + "=" + s.toString());

						}

						System.out.print("]");
					}
					System.out.println();

					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getDef(j, n) != -1) {

								System.out.print(" " + n + " <- " + ir.getIndirectionData().getDef(j, n));
								any = true;
							}
						}
						if (any) {

							System.out.println("\n");
						}
					}
				}
			}

		}

		graph.add(l);
		vgraph.add(ver);

	}

	public void initIR(IMethod method, SSAInstruction[] instructions, SymbolTable symbolTable, SSACFG cfg,
			SSAOptions options) {
		if (method == null) {
			throw new IllegalArgumentException("method is null");
		}
		this.method = method;
		this.instructions = instructions;
		this.symbolTable = symbolTable;
		this.cfg = cfg;
		this.options = options;

	}

	private void sendDataToinitIR(IR ir) {
		IMethod method = ir.getMethod();
		SSAInstruction[] instructions = ir.getInstructions();
		SymbolTable symbolTable = ir.getSymbolTable();
		SSACFG cfg = ir.getControlFlowGraph();
		this.names = ir.getNames();
		initIR(method, instructions, symbolTable, cfg, options);

		printIR(ir);
	}

	public static void main(String args[])
			throws IllegalArgumentException, IOException, CancelException, WalaException {

		String dir = "C:\\Users\\mumu\\Downloads\\jsFinder\\app";
		String file = "test.html"; // bundle-bg.js //htmlPage.html
		File f = new File(dir + "\\" + file);
		srcSnk = new SourceSink().getSrcSnkList(dir);
		JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());

		CallGraph cg = JSCallGraphBuilderUtil.makeHTMLCG(f.toURI().toURL());
		CallGraphGenerator cgg = new CallGraphGenerator();

		cgg.getFunctionNode(cg, dir, file);

	}

	private void getFunctionNode(CallGraph CG, String dir, String file) {

		if (CG != null) {
			Iterator<CGNode> iter = CG.iterator();

			CGNode node;
			while (iter.hasNext()) {
				node = iter.next();
				TypeName tempType = node.getMethod().getDeclaringClass().getName();
				if (tempType.toString().startsWith("L" + file)) {
					IR ir = node.getIR();
					sendDataToinitIR(ir);

				}
			}
			System.out.println(graph);
			System.out.println(vgraph);
			System.out.println(vulRelation);
			System.out.println("List of sensitive source variables:\n\n");
			System.out.println(sensitiveSrc);
			System.out.println("List of sensitive sink variables:\\n\\n");
			System.out.println(sensitiveSnk);
			// System.out.println(variableGraph);
			// System.out.println(map);
			System.out.println("\n\nSensitive variable flow path:\n\n");
			printMap(map);
			System.out.println(GetAllPaths(map));
			System.out.println(encryptedVariable);
			System.out.println(decryptedVariable);

		}
	}

	private void printMap(Map<String, List<String>> map) {
		for (String key : map.keySet()) {
			System.out.println(key + " = " + map.get(key));

		}
	}

}

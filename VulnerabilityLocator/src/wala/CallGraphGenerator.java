package wala;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.ibm.wala.cast.js.ipa.callgraph.JSCallGraphUtil;
import com.ibm.wala.cast.js.test.JSCallGraphBuilderUtil;
import com.ibm.wala.cast.js.translator.CAstRhinoTranslatorFactory;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSACFG;
import com.ibm.wala.ssa.SSAIndirectionData;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAOptions;
import com.ibm.wala.ssa.SSAPhiInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.ssa.SSACFG.BasicBlock;
import com.ibm.wala.types.TypeName;

import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.collections.HashMapFactory;

import com.ibm.wala.util.strings.StringStuff;

import ruleFile.SourceSink;
import ruleFile.SourceSinkTrack;

/**
 *
 * Date 04/10/2017 11:15:54 PM Author Rubaiyat Jahan Mumu
 * 
 **/

public class CallGraphGenerator {

	private IMethod method;
	private SSAOptions options;
	private SSACFG cfg;
	private SSAInstruction[] instructions;
	private SymbolTable symbolTable;
	private Collection<? extends SSAIndirectionData.Name> names = null;

	List<List<String>> graph = new ArrayList<List<String>>();
	List<String> node = new ArrayList<>();

	static List<SourceSinkTrack> srcSnk;
	

	List<List<String>> vgraph = new ArrayList<List<String>>();
	List<String> vnode = new ArrayList<>();
	List<String> vulRelation = new ArrayList<>();
	List<String> sensitiveSrc = new ArrayList<>();
	List<String> sensitiveSnk = new ArrayList<>();
	List<List<String>> variableGraph = new ArrayList<>();
	Map<String, List<String>> sourceVarMap = new HashMap<String, List<String>>();
	Map<String, List<String>> encryptedVarMap = new HashMap<String, List<String>>();
	List<String> encryptedVariable = new ArrayList<>();
	List<String> decryptedVariable = new ArrayList<>();

	private int createCallList(String a) {
		String[] name = a.split("/");
		node.add(name[2]);
		vnode.add(name[2]);
		return name.length;
	}

	private void getEncryptedAndDecryptedVar(String line) {
		String[] words = line.split(":|\\@| ");
		List<String> arrayToList = Arrays.asList(words);
		int pos = arrayToList.indexOf("lexical");
		if (pos != -1) {
			String func = arrayToList.get(pos + 1);
			Pattern encrypt = Pattern.compile("(?i)((.*?)((en))((code)|(cipher)|(crypt))(.*?))",
					Pattern.CASE_INSENSITIVE);
			Matcher encryptMatcher = encrypt.matcher(func);

			Pattern dncrypt = Pattern.compile("(?i)((.*?)((de))((code)|(cipher)|(crypt))(.*?))",
					Pattern.CASE_INSENSITIVE);
			Matcher decryptMatcher = dncrypt.matcher(func);

			Pattern pattern = Pattern.compile("(v[0-9]*\\s\\=)");
			Matcher matcher = pattern.matcher(line);
			String[] str = line.split(" |=");
			if (decryptMatcher.find()) {

				if (matcher.find()) {

					decryptedVariable.add(str[0]);

				}
			}

			if (encryptMatcher.find()) {
				if (matcher.find()) {

					encryptedVariable.add(str[0]);
					encryptedVarMap.put(str[0], new ArrayList<>());
				}

			}

		}
	}

	private String checkFuncCall(String line) {
		String[] words = line.split(":|\\@| ");
		List<String> arrayToList = Arrays.asList(words);
		int pos = arrayToList.indexOf("lexical");
		if (pos != -1) {
			String func = arrayToList.get(pos + 1);
			Pattern pattern = Pattern.compile("(?i)((.*?)((en)|(de))((code)|(cipher)|(crypt))(.*?))",
					Pattern.CASE_INSENSITIVE);
			Matcher matcher = pattern.matcher(func);

			if (matcher.find()) {
				vulRelation.add(func);
			}
			return func;
		}

		else
			return null;

	}

	private void getVariableUseGraph(String line1, String instType) {
		Pattern pattern = Pattern.compile("(v[0-9]*\\s\\=)");
		Matcher matcher = pattern.matcher(line1);
		String[] str = line1.split(" |=");
		if (instType == "src") {

			if (matcher.find()) {

				sensitiveSrc.add(str[0]);
				sourceVarMap.put(str[0], new ArrayList<String>());

			}
		}

		if (instType == "snk") {
			if (!sensitiveSnk.contains(str[0])) {
				sensitiveSnk.add(str[0]);
			}
		}
	}

	private void searchMatchingVar(String line) {

		String[] tokens = line.split("=");
		Pattern pattern = Pattern.compile("(v[0-9]+\\s\\=)");
		Matcher matcher = pattern.matcher(line);

		List<String> newKeysForSource = new ArrayList<String>();
		List<String> newKeysForEncrytedVar = new ArrayList<String>();

		if (tokens.length == 2) {
			if (matcher.find()) {
				tokens[1] += " ";// for matching in the regex
				for (String key : sourceVarMap.keySet()) {

					Pattern p = Pattern.compile(key + "[^(0-9)]");
					Matcher m = p.matcher(tokens[1]);

					if (m.find()) {
						String newKeySrc = tokens[0].trim();
						List<String> values = sourceVarMap.get(key);
						if (!values.contains(newKeySrc)) {
							values.add(newKeySrc);
						}
						if (!sourceVarMap.containsKey(newKeySrc)) {
							newKeysForSource.add(newKeySrc);
						}

					}
				}

				for (String key : newKeysForSource) {
					sourceVarMap.put(key, new ArrayList<>());
				}

				for (String key : encryptedVarMap.keySet()) {

					Pattern p2 = Pattern.compile(key + "[^(0-9)]");
					Matcher m2 = p2.matcher(tokens[1]);

					if (m2.find()) {
						String newKeyEnc = tokens[0].trim();
						List<String> values = encryptedVarMap.get(key);
						if (!values.contains(newKeyEnc)) {
							values.add(newKeyEnc);
						}
						if (!encryptedVarMap.containsKey(newKeyEnc)) {
							newKeysForEncrytedVar.add(newKeyEnc);
						}

					}
				}

				for (String key : newKeysForEncrytedVar) {
					encryptedVarMap.put(key, new ArrayList<>());
				}

			}
		}
	}

	private String getInstructions(String line) {
		if (line != null) {
			if (line.contains("binaryop")) {
				return "BINARY-OP";
			}
			if (line.contains("new")) {
				return "NEW";
			}
			if (line.contains("putfield")) {
				return "PUTFIELD";
			}

			if (line.contains("conditional branch")) {
				return "CONDITIONAL";
			}
			if (line.contains("return")) {
				return "RETURN";
			}

			if (line.contains("global:global")) {
				return "GLOBAL";
			}
			if (line.contains("phi")) {
				return "PHI";
			}

			if (line.contains("charAt") || line.contains("charCodeAt") || line.contains("concat")
					|| line.contains("endsWith") || line.contains("fromCharCode") || line.contains("includes")
					|| line.contains("indexOf") || line.contains("lastIndexOf") || line.contains("localeCompare")
					|| line.contains("match") || line.contains("repeat") || line.contains("replace")
					|| line.contains("search") || line.contains("slice") || line.contains("split")
					|| line.contains("startsWith") || line.contains("substr") || line.contains("substring")
					|| line.contains("toLocaleLowerCase") || line.contains("toLocaleUpperCase")
					|| line.contains("toLowerCase") || line.contains("toUpperCase") || line.contains("toString")
					|| line.contains("trim") || line.contains("valueOf")) {
				return "STRING-OP";
			}
		}
		return null;
	}

	public String getSrcSnkLineNumber(String instPosLine) {
		String[] str = instPosLine.split("\\[|\\]|\\(|\\)|:");

		List<String> list = Arrays.asList(str);

		if (list.size() == 11) {
			list.set(7, list.get(7).trim());

			String[] no = list.get(10).split(" ");
			no[1] = no[1].trim();

			for (int j = 0; j < srcSnk.size(); j++) {

				if (srcSnk.get(j).filename.equals(list.get(7)) && srcSnk.get(j).lineNumber.equals(no[1])) {
					return srcSnk.get(j).type;
				}
			}

		}

		return null;
	}

	public static void printList(List<String> list, List<String> line) {
		for (int i = 0; i < list.size(); i++)
			System.out.println(line.get(i) + " " + list.get(i));
	}

	private List<List<String>> GetAllPaths(Map<String, List<String>> variableUseMap) {

		List<List<String>> paths = new ArrayList<List<String>>();

		Stack<SubTree> stack = new Stack<SubTree>();
		for (String variable : variableUseMap.keySet()) {
			stack.push(new SubTree(variable, Arrays.asList(variable)));
			List<String> visited = new ArrayList<String>();
			do {
				SubTree item = stack.pop();
				visited.add(item.Node);
				boolean isChildFound = false;
				for (String key : variableUseMap.keySet()) {

					if (variableUseMap.get(key).contains(item.Node)) {
						List<String> newPath = new ArrayList<String>(item.Path);
						newPath.add(key);
						if (!visited.contains(key)) {
							stack.push(new SubTree(key, newPath));
							isChildFound = true;
						}

					}
				}
				if (!isChildFound) {
					paths.add(item.Path);
				}
			} while (!stack.isEmpty());
		}

		return paths;
	}

	public void printIR(IR ir) {

		String a = method.toString();
		int pos_window_main = a.indexOf("__WINDOW_MAIN__");
		int last = a.indexOf(">");
		int pos_make_node = a.indexOf("make_node");

		// remove unnecessary nodes
		if (pos_window_main == -1 || pos_make_node != -1 || pos_window_main + 15 == last)
			return;
		System.out.println("\n\n" + a + " ");

		if (createCallList(a) > 3)
			return;
		List<String> l = new ArrayList<String>();
		List<String> ver = new ArrayList<String>();

		if (node.size() > 0) {
			l.add("callee of " + node.get(node.size() - 1));
			ver.add("Instructions of " + vnode.get(vnode.size() - 1));
		}

		System.out.println("CFG:\n");

		for (int i = 0; i < cfg.getMaxNumber(); i++) {
			BasicBlock bb = cfg.getBasicBlock(i);
			int start = bb.getFirstInstructionIndex();
			int end = bb.getLastInstructionIndex();

			System.out.print("BB" + bb.getNumber() + "\n");
			System.out.println("Phi instructions: \n");
			for (Iterator it = bb.iteratePhis(); it.hasNext();) {
				SSAPhiInstruction phi = (SSAPhiInstruction) it.next();
				if (phi != null) {

					System.out.println(" " + phi.toString(symbolTable) + ("\n"));
					ver.add("PHI");

				}
			}

			System.out.println("Normal Instructions: \n");
			for (int j = start; j <= end; j++) {
				if (instructions[j] != null) {
					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getUse(j, n) != -1) {

								int s = ir.getIndirectionData().getUse(j, n);

								System.out.print(" " + n + " -> " + s);
								any = true;
							}
						}
						if (any) {

							System.out.println();
						}
					}
					StringBuffer x = new StringBuffer(j + "   " + instructions[j].toString(symbolTable) + "");

					String line = instructions[j].toString(symbolTable);
					String func = checkFuncCall(line);
					String inst = getInstructions(line);
					getEncryptedAndDecryptedVar(line);
					String instType = getSrcSnkLineNumber(ir.instructionPosition(j));
					getVariableUseGraph(line, instType);
					searchMatchingVar(line);
					if (instType != null)
						ver.add("Type: " + instType); // src or sink

					if (func != null) {
						l.add(func);
						ver.add("CALL " + func);
					} else if (inst != null) {
						ver.add(inst);
					}
					StringStuff.padWithSpaces(x, 45);
					System.out.print(x + "\n" + ir.instructionPosition(j));

					Map<Integer, Set<String>> valNames = HashMapFactory.make();
					for (int v = 0; v < instructions[j].getNumberOfDefs(); v++) {
						int valNum = instructions[j].getDef(v);
						ir.addNames(j, valNames, valNum);
					}
					for (int v = 0; v < instructions[j].getNumberOfUses(); v++) {
						int valNum = instructions[j].getUse(v);
						ir.addNames(j, valNames, valNum);
					}
					if (!valNames.isEmpty()) {

						System.out.print(" [");
						for (Map.Entry<Integer, Set<String>> e : valNames.entrySet()) {
							int key = e.getKey();
							Set<String> s = e.getValue();
							System.out.print(key + "=" + s.toString());

						}

						System.out.print("]");
					}
					System.out.println();

					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getDef(j, n) != -1) {

								System.out.print(" " + n + " <- " + ir.getIndirectionData().getDef(j, n));
								any = true;
							}
						}
						if (any) {

							System.out.println("\n");
						}
					}
				}
			}

		}

		graph.add(l);
		vgraph.add(ver);

	}

	public void initIR(IMethod method, SSAInstruction[] instructions, SymbolTable symbolTable, SSACFG cfg,
			SSAOptions options) {
		if (method == null) {
			throw new IllegalArgumentException("method is null");
		}
		this.method = method;
		this.instructions = instructions;
		this.symbolTable = symbolTable;
		this.cfg = cfg;
		this.options = options;

	}

	private void sendDataToinitIR(IR ir) {
		IMethod method = ir.getMethod();
		SSAInstruction[] instructions = ir.getInstructions();
		SymbolTable symbolTable = ir.getSymbolTable();
		SSACFG cfg = ir.getControlFlowGraph();
		this.names = ir.getNames();
		initIR(method, instructions, symbolTable, cfg, options);

		printIR(ir);
	}

	private List<List<String>> GetFilteredPathsWithSourceAndSinkOnly(List<List<String>> paths,
			List<String> sourceVariables, List<String> sinkVariables, List<String> encVars, List<String> decVars) {
		List<List<String>> filteredPaths = new ArrayList<>();
		boolean flag = false;
		for (List<String> path : paths) {
			boolean sourceContains = !Collections.disjoint(sourceVariables, path);
			boolean sinkContains = !Collections.disjoint(sinkVariables, path);
			if (sourceContains && sinkContains) {
				filteredPaths.add(path);
				if (!flag) {
					int size = 0;
					if (encVars.size() > decVars.size()) {
						size = encVars.size();
					} else {
						size = decVars.size();
					}
					for (int i = 0; i < size; i++) {
						if (i<encVars.size()) {
							path.add(encVars.get(i));
						}
						if (i< decVars.size()) {
							path.add(decVars.get(i));
						}

					}
					flag = true;
				}

			}
		}

		return filteredPaths;
	}

	private List<List<EncryptionDecryptionLocator>> getEncryptionDecryptionLocations(List<List<String>> paths,
			List<String> encryptedVars, List<String> decryptedVars) {
		List<List<EncryptionDecryptionLocator>> encryptionDecryptionListOfList = new ArrayList<>();
		for (List<String> path : paths) {
			List<EncryptionDecryptionLocator> encryptionDecryptionList = new ArrayList<>();
			int index = -1;
			for (String variable : path) {
				index++;
				
				if (encryptedVars.contains(variable)) {
					encryptionDecryptionList.add(new EncryptionDecryptionLocator("Encryption", variable, index));
				}

				if (decryptedVars.contains(variable)) {
					encryptionDecryptionList.add(new EncryptionDecryptionLocator("Decryption", variable, index));
				}

			}

			encryptionDecryptionList.sort((o1, o2) -> o1.position - o2.position);
			encryptionDecryptionListOfList.add(encryptionDecryptionList);
		}
		return encryptionDecryptionListOfList;
	}
	
	public void variableUseAnalysis(String directory, String filename)throws IllegalArgumentException,
	IOException, CancelException, WalaException {
		
		File f = new File(directory + "\\" + filename);
		srcSnk = new SourceSink().getSrcSnkList(directory);
		resetGlobalValues();
		JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());

		CallGraph cg = JSCallGraphBuilderUtil.makeHTMLCG(f.toURI().toURL());
		CallGraphGenerator cgg = new CallGraphGenerator();

		cgg.getFunctionNode(cg, directory,filename );
	}

	public static void main(String args[])
			throws IllegalArgumentException, IOException, CancelException, WalaException {

		String dir = "C:\\Users\\mumu\\Downloads\\New Extension\\content_script\\js";
		String file = "test.html"; // bundle-bg.js //htmlPage.html
		File f = new File(dir + "\\" + file);
		srcSnk = new SourceSink().getSrcSnkList(dir);
		JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());

		CallGraph cg = JSCallGraphBuilderUtil.makeHTMLCG(f.toURI().toURL());
		CallGraphGenerator cgg = new CallGraphGenerator();

		cgg.getFunctionNode(cg, dir, file);

	}
	
	private void resetGlobalValues() {
		 graph = new ArrayList<List<String>>();
		 node = new ArrayList<>();

		vgraph = new ArrayList<List<String>>();
		vnode = new ArrayList<>();
		vulRelation = new ArrayList<>();
		sensitiveSrc = new ArrayList<>();
		sensitiveSnk = new ArrayList<>();
		variableGraph = new ArrayList<>();
		sourceVarMap = new HashMap<String, List<String>>();
		encryptedVarMap = new HashMap<String, List<String>>();
		encryptedVariable = new ArrayList<>();
		decryptedVariable = new ArrayList<>();
	}

	/*
	 * private void addEncDecVars(List<List<EncryptionDecryptionLocator>>
	 * sourceLocator, List<String> encyptVar, List<String> decryptVar) {
	 * 
	 * }
	 */
	private void getFunctionNode(CallGraph CG, String dir, String file) {

		if (CG != null) {
			Iterator<CGNode> iter = CG.iterator();

			CGNode node;
			while (iter.hasNext()) {
				node = iter.next();
				TypeName tempType = node.getMethod().getDeclaringClass().getName();
				if (tempType.toString().startsWith("L" + file)) {
					IR ir = node.getIR();
					sendDataToinitIR(ir);

				}
			}
			System.out.println(graph);
			System.out.println(vgraph);
			System.out.println(vulRelation);

			// System.out.println(variableGraph);
			// System.out.println(map);
			System.out.println("\n\nSensitive source variable flow path:\n\n");
			printMap(sourceVarMap);
			
			System.out.println("\nSource to dataflow\n");
			List<List<String>> paths = GetAllPaths(sourceVarMap);
			printList(paths);
			System.out.println("List of sensitive source variables:\n\n");
			System.out.println(sensitiveSrc);
			System.out.println("\n\nList of sensitive sink variables:\n\n");
			System.out.println(sensitiveSnk);
			System.out.println("\nFiltered Paths:\n");
			List<List<String>> filteredPaths = GetFilteredPathsWithSourceAndSinkOnly(paths, sensitiveSrc, sensitiveSnk, encryptedVariable, decryptedVariable);
			printList(filteredPaths);
			List<List<EncryptionDecryptionLocator>> locations = getEncryptionDecryptionLocations(filteredPaths,
					encryptedVariable, decryptedVariable);
			System.out.println("\nEncryption Decryption variable locations:\n");
			System.out.println(locations);

			System.out.println("\nEncrypted Variables:\n");
			System.out.println(encryptedVariable);
			System.out.println("\nDecrypted variables:\n");
			System.out.println(decryptedVariable);

		}
	}

	private void printMap(Map<String, List<String>> map) {
		for (String key : map.keySet()) {
			System.out.println(key + " = " + map.get(key));

		}
	}

	private void printList(List<List<String>> list) {
		for (List<String> l : list) {
			System.out.println(l);
		}
	}

}

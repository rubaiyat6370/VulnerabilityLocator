package wala;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.ibm.wala.analysis.arraybounds.ArrayBoundsGraphBuilder;
import com.ibm.wala.cast.ir.ssa.AstIRFactory;
import com.ibm.wala.cast.js.callgraph.fieldbased.flowgraph.FlowGraph;
import com.ibm.wala.cast.js.callgraph.fieldbased.flowgraph.FlowGraphBuilder.FlowGraphSSAVisitor;
import com.ibm.wala.cast.js.ipa.callgraph.JSCallGraphUtil;
import com.ibm.wala.cast.js.test.JSCallGraphBuilderUtil;
import com.ibm.wala.cast.js.translator.CAstRhinoTranslatorFactory;
import com.ibm.wala.cast.types.AstMethodReference;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.AnalysisCache;

import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.impl.Everywhere;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.shrikeBT.info.ThisAssignmentChecker;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.IRFactory;
import com.ibm.wala.ssa.SSACFG;
import com.ibm.wala.ssa.SSAGetCaughtExceptionInstruction;
import com.ibm.wala.ssa.SSAIndirectionData;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAOptions;
import com.ibm.wala.ssa.SSAPhiInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.ssa.SSACFG.BasicBlock;
import com.ibm.wala.ssa.SSACFG.ExceptionHandlerBasicBlock;
import com.ibm.wala.types.TypeName;

import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.collections.HashMapFactory;

import com.ibm.wala.util.strings.StringStuff;

import ruleFile.SourceSink;
import java.util.Map;

/**
 *
 * Date 04/10/2017 11:15:54 PM Author Rubaiyat Jahan Mumu
 * 
 **/

public class CallGraphGenerator {

	private IMethod method;
	private SSAOptions options;
	private SSACFG cfg;
	private SSAInstruction[] instructions;
	private SymbolTable symbolTable;
	private Collection<? extends SSAIndirectionData.Name> names = null;

	List<List<String>> graph = new ArrayList<List<String>>();
	List<String> node = new ArrayList<>();
	
	static List<SourceSinkTrack> srcSnk;

	List<List<String>> vgraph = new ArrayList<List<String>>();
	List<String> vnode = new ArrayList<>();
	List<String> vulRelation = new ArrayList<>();
	List<String> sensitiveVar = new ArrayList<>();
	List<List<String>> variableGraph = new ArrayList<>();
	Map<String, List<String>> map = new HashMap<String, List<String>>(); 

	private int createCallList(String a) {
		String[] name = a.split("/");
		node.add(name[2]);
		vnode.add(name[2]);
		return name.length;
	}

	private String checkFuncCall(String line) {
		String[] words = line.split(":|\\@| ");
		List<String> arrayToList = Arrays.asList(words);
		int pos = arrayToList.indexOf("lexical");
		if (pos != -1) {
			String func = arrayToList.get(pos + 1);
			Pattern pattern = Pattern.compile("(?i)((.*?)((en)|(de))((code)|(cipher)|(crypt))(.*?))", Pattern.CASE_INSENSITIVE);
			Matcher matcher = pattern.matcher(func);
			
			if(matcher.find()) 
				vulRelation.add(func);
			return func;
		}

		else
			return null;

	}
	
	private void getVariableUseGraph(String line1, String instType) {
		if(instType=="src") {
			Pattern pattern = Pattern.compile("(v[0-9]*\\s\\=)");
			Matcher matcher = pattern.matcher(line1);
			
			if(matcher.find()) {
				String [] str = line1.split(" |=");
				sensitiveVar.add(str[0]);
				map.put(str[0], new ArrayList<String>());
				
				
			}
		}
	}
	
	private void searchMatchingVar(String line) {
		
		Pattern pattern = Pattern.compile("(v[0-9]+\\s\\=)");
		Matcher matcher = pattern.matcher(line);
		
		if(sensitiveVar.size()!=0) {
			if(matcher.find()) {
				
				for (String key : map.keySet()) 									
				{
					System.out.println("**"+key+"**");
					
					String[] str1 = line.split("=");
					str1[1] += " ";
					Pattern p = Pattern.compile(key+"[^(0-9)]");
					Matcher m = p.matcher(str1[1]);
					if(str1[1].contains("v14") && key.equals("v14"))
					{
				     int a =1;
					}
					if(m.find()) {
						
						List<String> l = map.get(key);
						l.add(str1[0].trim());
						
					}
				}
			}
		}
	}

	private String getInstructions(String line) {
		if (line != null) {
			if (line.contains("binaryop")) {
				return "BINARY-OP";
			}
			if (line.contains("new")) {
				return "NEW";
			}
			if (line.contains("putfield")) {
				return "PUTFIELD";
			}
			
			if (line.contains("conditional branch")) {
				return "CONDITIONAL";
			}
			if (line.contains("return")) {
				return "RETURN";
			}

			if (line.contains("global:global")) {
				return "GLOBAL";
			}
			if(line.contains("phi")) {
				return "PHI";
			}
			
			if (line.contains("charAt") || line.contains("charCodeAt")|| line.contains("concat") ||
					line.contains("endsWith") || line.contains("fromCharCode") || line.contains("includes") ||
					line.contains("indexOf") || line.contains("lastIndexOf") || line.contains("localeCompare") ||
					line.contains("match") || line.contains("repeat") || line.contains("replace") || 
					line.contains("search") || line.contains("slice") || line.contains("split") || 
					line.contains("startsWith") || line.contains("substr") || line.contains("substring") ||
					line.contains("toLocaleLowerCase") || line.contains("toLocaleUpperCase") || 
					line.contains("toLowerCase") || line.contains("toUpperCase") || line.contains("toString") || 
					line.contains("trim") || line.contains("valueOf")) {
				return "STRING-OP";
			}
		}
		return null;
	}
	
	public String getSrcSnkLineNumber(String instPosLine) {
		String [] str = instPosLine.split("\\[|\\]|\\(|\\)|:");
		
		List<String> list = Arrays.asList(str);
		
		if(list.size()==11)
		{
			list.set(7, list.get(7).trim());
			
			String[] no = list.get(10).split(" ");
			no[1] = no[1].trim();
			
			for(int j=0;j<srcSnk.size();j++)
			{
				
				if(srcSnk.get(j).filename.equals(list.get(7)) && srcSnk.get(j).lineNumber.equals(no[1]))
				{
					return srcSnk.get(j).type;
				}
			}

		}
		
		return null;
	}
	
	public static void printList(List<String> list, List<String> line)
	{
		for(int i=0;i<list.size();i++)
			System.out.println(line.get(i) + " " + list.get(i));
	}
	
	

	public void printIR(IR ir) {

		String a = method.toString();
		int pos_window_main = a.indexOf("__WINDOW_MAIN__");
		int last = a.indexOf(">");
		int pos_make_node = a.indexOf("make_node");

		// remove unnecessary nodes
		if (pos_window_main == -1 || pos_make_node != -1 || pos_window_main + 15 == last)
			return;
		System.out.println("\n\n" + a + " ");

		if (createCallList(a) > 3)
			return;
		List<String> l = new ArrayList<String>();
		List<String> ver = new ArrayList<String>();

		if (node.size() > 0) {
			l.add("callee of " + node.get(node.size() - 1));
			ver.add("Instructions of " + vnode.get(vnode.size() - 1));
		}
		
		System.out.println("CFG:\n");
		
		
		for (int i = 0; i < cfg.getMaxNumber(); i++) {
			BasicBlock bb = cfg.getBasicBlock(i);
			int start = bb.getFirstInstructionIndex();
			int end = bb.getLastInstructionIndex();
			
			System.out.print("BB" + bb.getNumber() + "\n");
			System.out.println("Phi instructions: \n");
			for (Iterator it = bb.iteratePhis(); it.hasNext();) {
				SSAPhiInstruction phi = (SSAPhiInstruction) it.next();
				if (phi != null) {
					
					System.out.println(" " + phi.toString(symbolTable) + ("\n"));
					ver.add("PHI");
					
				}
			}

			
			System.out.println("Normal Instructions: \n");
			for (int j = start; j <= end; j++) {
				if (instructions[j] != null) {
					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getUse(j, n) != -1) {
											
								int s = ir.getIndirectionData().getUse(j, n);
								
								System.out.print(" " + n + " -> " + s);
								any = true;
							}
						}
						if (any) {
							
							System.out.println();
						}
					}
					StringBuffer x = new StringBuffer(j + "   " + instructions[j].toString(symbolTable) + "");
					
					String func = checkFuncCall(instructions[j].toString(symbolTable));
					String inst = getInstructions(instructions[j].toString(symbolTable));
					
					String instType = getSrcSnkLineNumber(ir.instructionPosition(j));
					getVariableUseGraph(instructions[j].toString(symbolTable), instType);
					searchMatchingVar(instructions[j].toString(symbolTable));
					if(instType!= null)
						ver.add("Type: "+instType); //src or sink
					
					if (func != null) {
						l.add(func);
						ver.add("CALL " + func);
					}
					else if(inst!=null) {
						ver.add(inst);
					}
					StringStuff.padWithSpaces(x, 45);
					System.out.print(x + "   " + ir.instructionPosition(j));
					
					
					

					Map<Integer, Set<String>> valNames = HashMapFactory.make();
					for (int v = 0; v < instructions[j].getNumberOfDefs(); v++) {
						int valNum = instructions[j].getDef(v);
						ir.addNames(j, valNames, valNum);
					}
					for (int v = 0; v < instructions[j].getNumberOfUses(); v++) {
						int valNum = instructions[j].getUse(v);
						ir.addNames(j, valNames, valNum);
					}
					if (!valNames.isEmpty()) {
						
						System.out.print(" [");
						for (Map.Entry<Integer, Set<String>> e : valNames.entrySet()) {
							int key = e.getKey();
							Set<String> s = e.getValue();
							System.out.print(key + "=" + s.toString());
							
						}
						
						System.out.print("]");
					}
					System.out.println();
				

					if (names != null) {
						boolean any = false;
						for (SSAIndirectionData.Name n : names) {
							if (ir.getIndirectionData().getDef(j, n) != -1) {
								
								System.out.print(" " + n + " <- " + ir.getIndirectionData().getDef(j, n));
								any = true;
							}
						}
						if (any) {
							
							System.out.println("\n");
						}
					}
				}
			}

		}

		graph.add(l);
		vgraph.add(ver);
	

	}

	public void initIR(IMethod method, SSAInstruction[] instructions, SymbolTable symbolTable, SSACFG cfg,
			SSAOptions options) {
		if (method == null) {
			throw new IllegalArgumentException("method is null");
		}
		this.method = method;
		this.instructions = instructions;
		this.symbolTable = symbolTable;
		this.cfg = cfg;
		this.options = options;

	}

	private void sendDataToinitIR(IR ir) {
		IMethod method = ir.getMethod();
		SSAInstruction[] instructions = ir.getInstructions();
		SymbolTable symbolTable = ir.getSymbolTable();
		SSACFG cfg = ir.getControlFlowGraph();
		this.names = ir.getNames();
		initIR(method, instructions, symbolTable, cfg, options);

		printIR(ir);
	}

	public static void main(String args[])
			throws IllegalArgumentException, IOException, CancelException, WalaException {

		String dir = "C:\\Users\\mumu\\Downloads\\jsFinder\\app";
		String file = "test.html"; // bundle-bg.js //htmlPage.html
		File f = new File(dir + "\\" + file);
		srcSnk = new SourceSink().getSrcSnkList(dir);
		JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());

		CallGraph cg = JSCallGraphBuilderUtil.makeHTMLCG(f.toURI().toURL());
		CallGraphGenerator cgg = new CallGraphGenerator();

		cgg.getFunctionNode(cg, dir, file);
		
	}

	private void getFunctionNode(CallGraph CG, String dir, String file) {
		
		if (CG != null) {
			Iterator<CGNode> iter = CG.iterator();
			
			CGNode node;
			while (iter.hasNext()) {
				node = iter.next();
				TypeName tempType = node.getMethod().getDeclaringClass().getName();
				if (tempType.toString().startsWith("L" + file)) {	
					IR ir = node.getIR();
					sendDataToinitIR(ir);
				
				}
			}
			System.out.println(graph);
			System.out.println(vgraph);
			System.out.println(vulRelation);
			System.out.println(sensitiveVar);
			//System.out.println(variableGraph);
			System.out.println(map);
		}
	}

	


}
